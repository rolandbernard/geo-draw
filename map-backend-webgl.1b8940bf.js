(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{48:function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n\n        // filter collinear points around the cuts\n        filterPoints(outerNode, outerNode.next);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanM/NTY2NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyxLQUFLO0FBQ0wsMkJBQTJCLFlBQVk7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDOztBQUV6QyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLDRCQUE0QiwrQkFBK0I7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDOztBQUU1Qyx1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZELHVEQUF1RDtBQUN2RCx1REFBdUQ7O0FBRXZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDLHVCQUF1QixvQkFBb0I7QUFDM0MsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBlYXJjdXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQoZGF0YSwgaG9sZUluZGljZXMsIGRpbSkge1xuXG4gICAgZGltID0gZGltIHx8IDI7XG5cbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXG4gICAgICAgIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxuICAgICAgICBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUpLFxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmICghb3V0ZXJOb2RlIHx8IG91dGVyTm9kZS5uZXh0ID09PSBvdXRlck5vZGUucHJldikgcmV0dXJuIHRyaWFuZ2xlcztcblxuICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xuXG4gICAgaWYgKGhhc0hvbGVzKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pO1xuXG4gICAgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gODAgKiBkaW0pIHtcbiAgICAgICAgbWluWCA9IG1heFggPSBkYXRhWzBdO1xuICAgICAgICBtaW5ZID0gbWF4WSA9IGRhdGFbMV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xuICAgICAgICAgICAgeCA9IGRhdGFbaV07XG4gICAgICAgICAgICB5ID0gZGF0YVtpICsgMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cbiAgICAgICAgaW52U2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgICAgIGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMSAvIGludlNpemUgOiAwO1xuICAgIH1cblxuICAgIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHJldHVybiB0cmlhbmdsZXM7XG59XG5cbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xuICAgIHZhciBpLCBsYXN0O1xuXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSA+IDApKSB7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9XG5cbiAgICBpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuICAgICAgICByZW1vdmVOb2RlKGxhc3QpO1xuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0O1xufVxuXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0KSByZXR1cm4gc3RhcnQ7XG4gICAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuXG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgYWdhaW47XG4gICAgZG8ge1xuICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xuICAgICAgICAgICAgaWYgKHAgPT09IHAubmV4dCkgYnJlYWs7XG4gICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuXG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcykge1xuICAgIGlmICghZWFyKSByZXR1cm47XG5cbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG4gICAgaWYgKCFwYXNzICYmIGludlNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoaW52U2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkgOiBpc0VhcihlYXIpKSB7XG4gICAgICAgICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSk7XG5cbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcblxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGV4IGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xuICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYXIgPSBuZXh0O1xuXG4gICAgICAgIC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG4gICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG4gICAgICAgICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMik7XG5cbiAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICB2YXIgcCA9IGVhci5uZXh0Lm5leHQ7XG5cbiAgICB3aGlsZSAocCAhPT0gZWFyLnByZXYpIHtcbiAgICAgICAgaWYgKHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgbWluVFggPSBhLnggPCBiLnggPyAoYS54IDwgYy54ID8gYS54IDogYy54KSA6IChiLnggPCBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtaW5UWSA9IGEueSA8IGIueSA/IChhLnkgPCBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA8IGMueSA/IGIueSA6IGMueSksXG4gICAgICAgIG1heFRYID0gYS54ID4gYi54ID8gKGEueCA+IGMueCA/IGEueCA6IGMueCkgOiAoYi54ID4gYy54ID8gYi54IDogYy54KSxcbiAgICAgICAgbWF4VFkgPSBhLnkgPiBiLnkgPyAoYS55ID4gYy55ID8gYS55IDogYy55KSA6IChiLnkgPiBjLnkgPyBiLnkgOiBjLnkpO1xuXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICB2YXIgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIGludlNpemUpLFxuICAgICAgICBtYXhaID0gek9yZGVyKG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICB2YXIgcCA9IGVhci5wcmV2WixcbiAgICAgICAgbiA9IGVhci5uZXh0WjtcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aICYmIG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuXG4gICAgICAgIGlmIChuICE9PSBlYXIucHJldiAmJiBuICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJlxuICAgICAgICAgICAgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XG4gICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChuICE9PSBlYXIucHJldiAmJiBuICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJlxuICAgICAgICAgICAgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcbmZ1bmN0aW9uIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoc3RhcnQsIHRyaWFuZ2xlcywgZGltKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBhID0gcC5wcmV2LFxuICAgICAgICAgICAgYiA9IHAubmV4dC5uZXh0O1xuXG4gICAgICAgIGlmICghZXF1YWxzKGEsIGIpICYmIGludGVyc2VjdHMoYSwgcCwgcC5uZXh0LCBiKSAmJiBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkpIHtcblxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0pO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xuXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGZpbHRlclBvaW50cyhwKTtcbn1cblxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgdmFyIGEgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBzcGxpdFBvbHlnb24oYSwgYik7XG5cbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICBjID0gZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG4vLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG4gICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgICAgIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cblxuICAgIHF1ZXVlLnNvcnQoY29tcGFyZVgpO1xuXG4gICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICAgICAgb3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS54IC0gYi54O1xufVxuXG4vLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgb3V0ZXJOb2RlID0gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcbiAgICBpZiAob3V0ZXJOb2RlKSB7XG4gICAgICAgIHZhciBiID0gc3BsaXRQb2x5Z29uKG91dGVyTm9kZSwgaG9sZSk7XG5cbiAgICAgICAgLy8gZmlsdGVyIGNvbGxpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgICAgIGZpbHRlclBvaW50cyhvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0KTtcbiAgICAgICAgZmlsdGVyUG9pbnRzKGIsIGIubmV4dCk7XG4gICAgfVxufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgcCA9IG91dGVyTm9kZSxcbiAgICAgICAgaHggPSBob2xlLngsXG4gICAgICAgIGh5ID0gaG9sZS55LFxuICAgICAgICBxeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbTtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgICAgICAgICAgcXggPSB4O1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAueSkgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC5uZXh0LnkpIHJldHVybiBwLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChoeCA9PT0gcXgpIHJldHVybiBtOyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsZWZ0bW9zdCBlbmRwb2ludFxuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cbiAgICB2YXIgc3RvcCA9IG0sXG4gICAgICAgIG14ID0gbS54LFxuICAgICAgICBteSA9IG0ueSxcbiAgICAgICAgdGFuTWluID0gSW5maW5pdHksXG4gICAgICAgIHRhbjtcblxuICAgIHAgPSBtO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXG4gICAgICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xuXG4gICAgICAgICAgICB0YW4gPSBNYXRoLmFicyhoeSAtIHAueSkgLyAoaHggLSBwLngpOyAvLyB0YW5nZW50aWFsXG5cbiAgICAgICAgICAgIGlmIChsb2NhbGx5SW5zaWRlKHAsIGhvbGUpICYmXG4gICAgICAgICAgICAgICAgKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgKHAueCA+IG0ueCB8fCAocC54ID09PSBtLnggJiYgc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkpKSkpKSB7XG4gICAgICAgICAgICAgICAgbSA9IHA7XG4gICAgICAgICAgICAgICAgdGFuTWluID0gdGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdG9wKTtcblxuICAgIHJldHVybiBtO1xufVxuXG4vLyB3aGV0aGVyIHNlY3RvciBpbiB2ZXJ0ZXggbSBjb250YWlucyBzZWN0b3IgaW4gdmVydGV4IHAgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZXNcbmZ1bmN0aW9uIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApIHtcbiAgICByZXR1cm4gYXJlYShtLnByZXYsIG0sIHAucHJldikgPCAwICYmIGFyZWEocC5uZXh0LCBtLCBtLm5leHQpIDwgMDtcbn1cblxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC56ID09PSBudWxsKSBwLnogPSB6T3JkZXIocC54LCBwLnksIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICBwLnByZXZaID0gcC5wcmV2O1xuICAgICAgICBwLm5leHRaID0gcC5uZXh0O1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHAucHJldloubmV4dFogPSBudWxsO1xuICAgIHAucHJldlogPSBudWxsO1xuXG4gICAgc29ydExpbmtlZChwKTtcbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcbiAgICB2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsXG4gICAgICAgIGluU2l6ZSA9IDE7XG5cbiAgICBkbyB7XG4gICAgICAgIHAgPSBsaXN0O1xuICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbCA9IG51bGw7XG4gICAgICAgIG51bU1lcmdlcyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIG51bU1lcmdlcysrO1xuICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICBwU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwU2l6ZSsrO1xuICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgIGlmICghcSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcblxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocFNpemUgIT09IDAgJiYgKHFTaXplID09PSAwIHx8ICFxIHx8IHAueiA8PSBxLnopKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO1xuICAgICAgICAgICAgICAgIGVsc2UgbGlzdCA9IGU7XG5cbiAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgICAgICAgICB0YWlsID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgIH1cblxuICAgICAgICB0YWlsLm5leHRaID0gbnVsbDtcbiAgICAgICAgaW5TaXplICo9IDI7XG5cbiAgICB9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcblxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBpbnZlcnNlIG9mIHRoZSBsb25nZXIgc2lkZSBvZiBkYXRhIGJib3hcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuICAgIHggPSAzMjc2NyAqICh4IC0gbWluWCkgKiBpbnZTaXplO1xuICAgIHkgPSAzMjc2NyAqICh5IC0gbWluWSkgKiBpbnZTaXplO1xuXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCB8fCAocC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpKSBsZWZ0bW9zdCA9IHA7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSAtIChheCAtIHB4KSAqIChjeSAtIHB5KSA+PSAwICYmXG4gICAgICAgICAgIChheCAtIHB4KSAqIChieSAtIHB5KSAtIChieCAtIHB4KSAqIChheSAtIHB5KSA+PSAwICYmXG4gICAgICAgICAgIChieCAtIHB4KSAqIChjeSAtIHB5KSAtIChjeCAtIHB4KSAqIChieSAtIHB5KSA+PSAwO1xufVxuXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiYgLy8gZG9uZXMndCBpbnRlcnNlY3Qgb3RoZXIgZWRnZXNcbiAgICAgICAgICAgKGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYikgJiYgLy8gbG9jYWxseSB2aXNpYmxlXG4gICAgICAgICAgICAoYXJlYShhLnByZXYsIGEsIGIucHJldikgfHwgYXJlYShhLCBiLnByZXYsIGIpKSB8fCAvLyBkb2VzIG5vdCBjcmVhdGUgb3Bwb3NpdGUtZmFjaW5nIHNlY3RvcnNcbiAgICAgICAgICAgIGVxdWFscyhhLCBiKSAmJiBhcmVhKGEucHJldiwgYSwgYS5uZXh0KSA+IDAgJiYgYXJlYShiLnByZXYsIGIsIGIubmV4dCkgPiAwKTsgLy8gc3BlY2lhbCB6ZXJvLWxlbmd0aCBjYXNlXG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgdmFyIG8xID0gc2lnbihhcmVhKHAxLCBxMSwgcDIpKTtcbiAgICB2YXIgbzIgPSBzaWduKGFyZWEocDEsIHExLCBxMikpO1xuICAgIHZhciBvMyA9IHNpZ24oYXJlYShwMiwgcTIsIHAxKSk7XG4gICAgdmFyIG80ID0gc2lnbihhcmVhKHAyLCBxMiwgcTEpKTtcblxuICAgIGlmIChvMSAhPT0gbzIgJiYgbzMgIT09IG80KSByZXR1cm4gdHJ1ZTsgLy8gZ2VuZXJhbCBjYXNlXG5cbiAgICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBwMiBhcmUgY29sbGluZWFyIGFuZCBwMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBxMiBhcmUgY29sbGluZWFyIGFuZCBxMiBsaWVzIG9uIHAxcTFcbiAgICBpZiAobzMgPT09IDAgJiYgb25TZWdtZW50KHAyLCBwMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBwMSBhcmUgY29sbGluZWFyIGFuZCBwMSBsaWVzIG9uIHAycTJcbiAgICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBxMSBhcmUgY29sbGluZWFyIGFuZCBxMSBsaWVzIG9uIHAycTJcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gZm9yIGNvbGxpbmVhciBwb2ludHMgcCwgcSwgciwgY2hlY2sgaWYgcG9pbnQgcSBsaWVzIG9uIHNlZ21lbnQgcHJcbmZ1bmN0aW9uIG9uU2VnbWVudChwLCBxLCByKSB7XG4gICAgcmV0dXJuIHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSAmJiBxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSk7XG59XG5cbmZ1bmN0aW9uIHNpZ24obnVtKSB7XG4gICAgcmV0dXJuIG51bSA+IDAgPyAxIDogbnVtIDwgMCA/IC0xIDogMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgcCA9IGE7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPCAwID9cbiAgICAgICAgYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxuICAgICAgICBhcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IGFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcbiAgICB2YXIgcCA9IGEsXG4gICAgICAgIGluc2lkZSA9IGZhbHNlLFxuICAgICAgICBweCA9IChhLnggKyBiLngpIC8gMixcbiAgICAgICAgcHkgPSAoYS55ICsgYi55KSAvIDI7XG4gICAgZG8ge1xuICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxuICAgICAgICAgICAgICAgIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuICAgICAgICBhbiA9IGEubmV4dCxcbiAgICAgICAgYnAgPSBiLnByZXY7XG5cbiAgICBhLm5leHQgPSBiO1xuICAgIGIucHJldiA9IGE7XG5cbiAgICBhMi5uZXh0ID0gYW47XG4gICAgYW4ucHJldiA9IGEyO1xuXG4gICAgYjIubmV4dCA9IGEyO1xuICAgIGEyLnByZXYgPSBiMjtcblxuICAgIGJwLm5leHQgPSBiMjtcbiAgICBiMi5wcmV2ID0gYnA7XG5cbiAgICByZXR1cm4gYjI7XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG4gICAgLy8gdmVydGV4IGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XG4gICAgdGhpcy5pID0gaTtcblxuICAgIC8vIHZlcnRleCBjb29yZGluYXRlc1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRleCBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcblxuICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICB0aGlzLnogPSBudWxsO1xuXG4gICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xuXG4gICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcbiAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbn1cblxuLy8gcmV0dXJuIGEgcGVyY2VudGFnZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHBvbHlnb24gYXJlYSBhbmQgaXRzIHRyaWFuZ3VsYXRpb24gYXJlYTtcbi8vIHVzZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzIG9mIHRyaWFuZ3VsYXRpb25cbmVhcmN1dC5kZXZpYXRpb24gPSBmdW5jdGlvbiAoZGF0YSwgaG9sZUluZGljZXMsIGRpbSwgdHJpYW5nbGVzKSB7XG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblxuICAgIHZhciBwb2x5Z29uQXJlYSA9IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSkpO1xuICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBwb2x5Z29uQXJlYSAtPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyaWFuZ2xlc0FyZWEgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGEgPSB0cmlhbmdsZXNbaV0gKiBkaW07XG4gICAgICAgIHZhciBiID0gdHJpYW5nbGVzW2kgKyAxXSAqIGRpbTtcbiAgICAgICAgdmFyIGMgPSB0cmlhbmdsZXNbaSArIDJdICogZGltO1xuICAgICAgICB0cmlhbmdsZXNBcmVhICs9IE1hdGguYWJzKFxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2NdKSAqIChkYXRhW2IgKyAxXSAtIGRhdGFbYSArIDFdKSAtXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbYl0pICogKGRhdGFbYyArIDFdIC0gZGF0YVthICsgMV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9seWdvbkFyZWEgPT09IDAgJiYgdHJpYW5nbGVzQXJlYSA9PT0gMCA/IDAgOlxuICAgICAgICBNYXRoLmFicygodHJpYW5nbGVzQXJlYSAtIHBvbHlnb25BcmVhKSAvIHBvbHlnb25BcmVhKTtcbn07XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcbiAgICAgICAgaiA9IGk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbi8vIHR1cm4gYSBwb2x5Z29uIGluIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkgZm9ybSAoZS5nLiBhcyBpbiBHZW9KU09OKSBpbnRvIGEgZm9ybSBFYXJjdXQgYWNjZXB0c1xuZWFyY3V0LmZsYXR0ZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxuICAgICAgICBob2xlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///48\n")},50:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js\nvar slicedToArray = __webpack_require__(21);\nvar slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\nvar taggedTemplateLiteral = __webpack_require__(10);\nvar taggedTemplateLiteral_default = /*#__PURE__*/__webpack_require__.n(taggedTemplateLiteral);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js\nvar classCallCheck = __webpack_require__(12);\nvar classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js\nvar createClass = __webpack_require__(13);\nvar createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js\nvar inherits = __webpack_require__(18);\nvar inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\nvar possibleConstructorReturn = __webpack_require__(19);\nvar possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js\nvar getPrototypeOf = __webpack_require__(17);\nvar getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);\n\n// EXTERNAL MODULE: ./node_modules/lit-element/lit-element.js + 5 modules\nvar lit_element = __webpack_require__(11);\n\n// EXTERNAL MODULE: ./node_modules/earcut/src/earcut.js\nvar earcut = __webpack_require__(48);\nvar earcut_default = /*#__PURE__*/__webpack_require__.n(earcut);\n\n// EXTERNAL MODULE: ./src/util.js\nvar util = __webpack_require__(29);\n\n// CONCATENATED MODULE: ./src/map/shaders/fill-fragment-shader.glsl\n/* harmony default export */ var fill_fragment_shader = ("\\n#ifdef GL_ES\\n    precision highp float;\\n#endif\\n    \\nuniform vec3 uFillColor;\\n\\nvoid main() {\\n    gl_FragColor = vec4(uFillColor, 1.0);\\n}\\n");\n// CONCATENATED MODULE: ./src/map/shaders/fill-vertex-shader.glsl\n/* harmony default export */ var fill_vertex_shader = ("\\nattribute vec2 aVertexPosition;\\n\\nuniform vec2 uTranslate;\\nuniform vec2 uScale;\\n\\nvoid main() {\\n    gl_Position = vec4((aVertexPosition + uTranslate) * uScale, 0.0, 1.0);\\n}\\n");\n// CONCATENATED MODULE: ./src/map/shaders/stroke-fragment-shader.glsl\n/* harmony default export */ var stroke_fragment_shader = ("\\n#ifdef GL_ES\\n    precision highp float;\\n#endif\\n    \\nuniform vec3 uStrokeColor;\\n\\nvoid main() {\\n    gl_FragColor = vec4(uStrokeColor, 1.0);\\n}\\n    ");\n// CONCATENATED MODULE: ./src/map/shaders/stroke-vertex-shader.glsl\n/* harmony default export */ var stroke_vertex_shader = ("\\nattribute vec2 aVertexPosition;\\nattribute vec2 aVertexNormal;\\n\\nuniform vec2 uTranslate;\\nuniform vec2 uScale;\\nuniform vec2 uStrokeScale;\\nuniform float uWidth;\\n\\nvoid main() {\\n    gl_Position = vec4(\\n        (aVertexPosition + uTranslate) * uScale + normalize(aVertexNormal) * uWidth * uStrokeScale,\\n        0.0, 1.0);\\n}\\n");\n// CONCATENATED MODULE: ./src/map/map-backend-webgl.js\n\n\n\n\n\n\n\n\nfunction _templateObject2() {\n  var data = taggedTemplateLiteral_default()(["\\n            <canvas\\n                id=\\"map\\"\\n                @mousemove=\\"", "\\"\\n                @wheel=\\"", "\\"\\n                @mouseout=\\"", "\\"\\n                @touchstart=\\"", "\\"\\n                @touchmove=\\"", "\\"\\n            >\\n            </canvas>\\n        "]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _templateObject() {\n  var data = taggedTemplateLiteral_default()(["\\n            :host {\\n                width: 100%;\\n                height: 100%;\\n                position: relative;\\n                display: block;\\n            }\\n            #map {\\n                width: 100%;\\n                height: 100%;\\n                max-width: 100%;\\n                max-height: 100%;\\n                display: block;\\n                position: absolute;\\n            }\\n        "]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n\n\n\nvar location_data_cache = {};\n\nvar map_backend_webgl_MapBackendWebGl = /*#__PURE__*/function (_LitElement) {\n  inherits_default()(MapBackendWebGl, _LitElement);\n\n  var _super = _createSuper(MapBackendWebGl);\n\n  createClass_default()(MapBackendWebGl, null, [{\n    key: "properties",\n    get: function get() {\n      return {\n        locations: {\n          type: Array\n        }\n      };\n    }\n  }, {\n    key: "styles",\n    get: function get() {\n      return Object(lit_element["b" /* css */])(_templateObject());\n    }\n  }]);\n\n  function MapBackendWebGl() {\n    var _this;\n\n    classCallCheck_default()(this, MapBackendWebGl);\n\n    _this = _super.call(this);\n    _this.zoom_scale = 1;\n    _this.zoom_center = [0, 0];\n    _this.min = [0, 0];\n    _this.max = [0, 0];\n    _this.current_hover = null;\n    return _this;\n  }\n\n  createClass_default()(MapBackendWebGl, [{\n    key: "setCenterAndScale",\n    value: function setCenterAndScale(center, scale) {\n      this.zoom_center = center;\n      this.zoom_scale = scale;\n    }\n  }, {\n    key: "clientPosToMapPos",\n    value: function clientPosToMapPos(client_pos) {\n      var map = this.shadowRoot.getElementById(\'map\');\n      var map_pos = map.getBoundingClientRect();\n\n      var _this$generateTransla = this.generateTranslateAndScale(),\n          _this$generateTransla2 = slicedToArray_default()(_this$generateTransla, 2),\n          _ = _this$generateTransla2[0],\n          scale = _this$generateTransla2[1];\n\n      var client_pos_norm = [2 * (client_pos[0] - map_pos.x) / map_pos.width - 1.0, 1.0 - 2 * (client_pos[1] - map_pos.y) / map_pos.height];\n      return [client_pos_norm[0] / scale[0] + this.zoom_center[0], client_pos_norm[1] / scale[1] + this.zoom_center[1]];\n    }\n  }, {\n    key: "clientPosToLocationPos",\n    value: function clientPosToLocationPos(client_pos) {\n      var map = this.shadowRoot.getElementById(\'map\');\n      var map_pos = map.getBoundingClientRect();\n\n      var _this$generateTransla3 = this.generateTranslateAndScale(),\n          _this$generateTransla4 = slicedToArray_default()(_this$generateTransla3, 2),\n          transform = _this$generateTransla4[0],\n          scale = _this$generateTransla4[1];\n\n      var client_pos_norm = [2 * (client_pos[0] - map_pos.x) / map_pos.width - 1.0, 1.0 - 2 * (client_pos[1] - map_pos.y) / map_pos.height];\n      return [client_pos_norm[0] / scale[0] - transform[0], client_pos_norm[1] / scale[1] - transform[1]];\n    }\n  }, {\n    key: "locationPosToClientPos",\n    value: function locationPosToClientPos(location_pos) {\n      var map = this.shadowRoot.getElementById(\'map\');\n      var map_pos = map.getBoundingClientRect();\n\n      var _this$generateTransla5 = this.generateTranslateAndScale(),\n          _this$generateTransla6 = slicedToArray_default()(_this$generateTransla5, 2),\n          transform = _this$generateTransla6[0],\n          scale = _this$generateTransla6[1];\n\n      var client_pos_norm = [(location_pos[0] + transform[0]) * scale[0], (location_pos[1] + transform[1]) * scale[1]];\n      return [(client_pos_norm[0] + 1.0) / 2 * map_pos.width + map_pos.x, (1.0 - client_pos_norm[1]) / 2 * map_pos.height + map_pos.y];\n    }\n  }, {\n    key: "handleMouseMove",\n    value: function handleMouseMove(event) {\n      var pos = this.clientPosToLocationPos([event.clientX, event.clientY]);\n\n      var _iterator = _createForOfIteratorHelper(this.locations),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var loc = _step.value;\n\n          if (loc.min[0] <= pos[0] && loc.min[1] <= pos[1] && loc.max[0] >= pos[0] && loc.max[1] >= pos[1]) {\n            var location = location_data_cache[loc.id];\n\n            var _iterator2 = _createForOfIteratorHelper(location.polygons),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var polygon = _step2.value;\n\n                if (polygon.min[0] <= pos[0] && polygon.min[1] <= pos[1] && polygon.max[0] >= pos[0] && polygon.max[1] >= pos[1]) {\n                  for (var i = 0; i < polygon.triangles.length; i += 3) {\n                    var v1 = [polygon.vertices[2 * polygon.triangles[i]], polygon.vertices[2 * polygon.triangles[i] + 1]];\n                    var v2 = [polygon.vertices[2 * polygon.triangles[i + 1]], polygon.vertices[2 * polygon.triangles[i + 1] + 1]];\n                    var v3 = [polygon.vertices[2 * polygon.triangles[i + 2]], polygon.vertices[2 * polygon.triangles[i + 2] + 1]];\n\n                    function sign(p1, p2, p3) {\n                      return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1]);\n                    }\n\n                    var d1 = sign(pos, v1, v2);\n                    var d2 = sign(pos, v2, v3);\n                    var d3 = sign(pos, v3, v1);\n                    var has_neg = d1 < 0 || d2 < 0 || d3 < 0;\n                    var has_pos = d1 > 0 || d2 > 0 || d3 > 0;\n\n                    if (!(has_neg && has_pos)) {\n                      this.current_hover = loc.id;\n                      var my_event = new Event(\'hover\');\n                      my_event.location = loc;\n                      my_event.position = this.locationPosToClientPos([(polygon.min[0] + polygon.max[0]) / 2, (polygon.min[1] + polygon.max[1]) / 2]);\n                      this.dispatchEvent(my_event);\n                      return;\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.handleMouseOut();\n    }\n  }, {\n    key: "handleMouseOut",\n    value: function handleMouseOut() {\n      this.current_hover = null;\n      var my_event = new Event(\'hover\');\n      my_event.location = null;\n      my_event.position = null;\n      this.dispatchEvent(my_event);\n    }\n  }, {\n    key: "handleTouchStart",\n    value: function handleTouchStart(event) {\n      if (event.touches.length === 1) {\n        this.handleMouseMove({\n          clientX: event.touches[0].clientX,\n          clientY: event.touches[0].clientY\n        });\n      } else {\n        this.handleMouseOut(event);\n      }\n    }\n  }, {\n    key: "generateTranslateAndScale",\n    value: function generateTranslateAndScale() {\n      var width = this.max[0] - this.min[0];\n      var height = this.max[1] - this.min[1];\n\n      if (width / this.current_size[0] > height / this.current_size[1]) {\n        var translate = [-this.min[0] - width / 2 - this.zoom_center[0], -this.min[1] - height / 2 - this.zoom_center[1]];\n        var scale = [2 / width * this.zoom_scale, -2 * (this.current_size[0] / this.current_size[1]) / width * this.zoom_scale];\n        var stroke_scale = [1, -this.current_size[0] / this.current_size[1]];\n        return [translate, scale, stroke_scale];\n      } else {\n        var _translate = [-this.min[0] - width / 2 - this.zoom_center[0], -this.min[1] - height / 2 - this.zoom_center[1]];\n        var _scale = [2 * (this.current_size[1] / this.current_size[0]) / height * this.zoom_scale, -2 / height * this.zoom_scale];\n        var _stroke_scale = [this.current_size[1] / this.current_size[0], -1];\n        return [_translate, _scale, _stroke_scale];\n      }\n    }\n  }, {\n    key: "renderMapInCanvas",\n    value: function renderMapInCanvas() {\n      if (this.last_center != this.zoom_center || this.last_scale != this.zoom_scale || this.last_hover != this.current_hover || this.last_size != this.current_size) {\n        var gl = this.webgl_data.context;\n        var fill_data = this.webgl_data.fill_data;\n        var stroke_data = this.webgl_data.stroke_data;\n\n        var _this$generateTransla7 = this.generateTranslateAndScale(),\n            _this$generateTransla8 = slicedToArray_default()(_this$generateTransla7, 3),\n            translate = _this$generateTransla8[0],\n            scale = _this$generateTransla8[1],\n            stroke_scale = _this$generateTransla8[2];\n\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        var _iterator3 = _createForOfIteratorHelper(this.locations),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var loc = _step3.value;\n            var location = location_data_cache[loc.id]; // Draw stroke\n\n            gl.useProgram(stroke_data.shader_program);\n            gl.uniform2fv(stroke_data.translate_uniform, translate);\n            gl.uniform2fv(stroke_data.scale_uniform, scale);\n            gl.uniform2fv(stroke_data.scale2_uniform, stroke_scale);\n            gl.uniform1f(stroke_data.width_uniform, 0.005);\n            gl.uniform3fv(stroke_data.color_uniform, [0.271, 0.302, 0.38]);\n\n            var _iterator4 = _createForOfIteratorHelper(location.polygons),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var polygon = _step4.value;\n                gl.bindBuffer(gl.ARRAY_BUFFER, polygon.gl_outline_position_buffer);\n                gl.vertexAttribPointer(stroke_data.position_attribute, 2, gl.FLOAT, false, 0, 0);\n                gl.enableVertexAttribArray(stroke_data.position_attribute);\n                gl.bindBuffer(gl.ARRAY_BUFFER, polygon.gl_outline_normal_buffer);\n                gl.vertexAttribPointer(stroke_data.normal_attribute, 2, gl.FLOAT, false, 0, 0);\n                gl.enableVertexAttribArray(stroke_data.normal_attribute);\n                var offset = 0;\n\n                var _iterator6 = _createForOfIteratorHelper(polygon.coords),\n                    _step6;\n\n                try {\n                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                    var part = _step6.value;\n                    gl.drawArrays(gl.TRIANGLE_STRIP, offset * 4, (part.length + 1) * 4);\n                    offset += part.length + 1;\n                  }\n                } catch (err) {\n                  _iterator6.e(err);\n                } finally {\n                  _iterator6.f();\n                }\n              } // Draw fill\n\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            gl.useProgram(fill_data.shader_program);\n            gl.uniform2fv(fill_data.translate_uniform, translate);\n            gl.uniform2fv(fill_data.scale_uniform, scale);\n\n            if (loc.id === this.current_hover) {\n              gl.uniform3fv(fill_data.color_uniform, loc.color.map(function (el) {\n                return el * 0.8;\n              }));\n            } else {\n              gl.uniform3fv(fill_data.color_uniform, loc.color);\n            }\n\n            var _iterator5 = _createForOfIteratorHelper(location.polygons),\n                _step5;\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var _polygon = _step5.value;\n                gl.bindBuffer(gl.ARRAY_BUFFER, _polygon.gl_position_buffer);\n                gl.vertexAttribPointer(fill_data.position_attribute, 2, gl.FLOAT, false, 0, 0);\n                gl.enableVertexAttribArray(fill_data.position_attribute);\n                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _polygon.gl_index_buffer);\n                gl.drawElements(gl.TRIANGLES, _polygon.triangles.length, gl.UNSIGNED_SHORT, 0);\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        this.last_center = this.zoom_center;\n        this.last_scale = this.zoom_scale;\n        this.last_hover = this.current_hover;\n        this.last_size = this.current_size;\n      }\n\n      window.requestAnimationFrame(this.renderMapInCanvas.bind(this));\n    }\n  }, {\n    key: "firstUpdated",\n    value: function firstUpdated() {\n      var _this2 = this;\n\n      var canvas = this.shadowRoot.getElementById(\'map\');\n      this.current_size = [canvas.width, canvas.height];\n      var gl = canvas.getContext(\'webgl\') || canvas.getContext(\'experimental-webgl\');\n\n      function createShaderProgram(vertex_shader_source, fragment_shader_source) {\n        var vertex_shader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertex_shader, vertex_shader_source);\n        gl.compileShader(vertex_shader);\n        var fragment_shader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragment_shader, fragment_shader_source);\n        gl.compileShader(fragment_shader);\n        var shader_program = gl.createProgram();\n        gl.attachShader(shader_program, vertex_shader);\n        gl.attachShader(shader_program, fragment_shader);\n        gl.linkProgram(shader_program);\n        return shader_program;\n      }\n\n      var fill_shader_program = createShaderProgram(fill_vertex_shader, fill_fragment_shader);\n      var fill_position_attribute = gl.getAttribLocation(fill_shader_program, \'aVertexPosition\');\n      var fill_translate_uniform = gl.getUniformLocation(fill_shader_program, \'uTranslate\');\n      var fill_scale_uniform = gl.getUniformLocation(fill_shader_program, \'uScale\');\n      var fill_color_uniform = gl.getUniformLocation(fill_shader_program, \'uFillColor\');\n      var stroke_shader_program = createShaderProgram(stroke_vertex_shader, stroke_fragment_shader);\n      var stroke_position_attribute = gl.getAttribLocation(stroke_shader_program, \'aVertexPosition\');\n      var stroke_normal_attribute = gl.getAttribLocation(stroke_shader_program, \'aVertexNormal\');\n      var stroke_translate_uniform = gl.getUniformLocation(stroke_shader_program, \'uTranslate\');\n      var stroke_scale_uniform = gl.getUniformLocation(stroke_shader_program, \'uScale\');\n      var stroke_scale2_uniform = gl.getUniformLocation(stroke_shader_program, \'uStrokeScale\');\n      var stroke_width_uniform = gl.getUniformLocation(stroke_shader_program, \'uWidth\');\n      var stroke_color_uniform = gl.getUniformLocation(stroke_shader_program, \'uStrokeColor\');\n\n      var _iterator7 = _createForOfIteratorHelper(this.locations),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var location = _step7.value;\n\n          var _iterator8 = _createForOfIteratorHelper(location_data_cache[location.id].polygons),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var polygon = _step8.value;\n              var position_buffer = gl.createBuffer();\n              gl.bindBuffer(gl.ARRAY_BUFFER, position_buffer);\n              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(polygon.vertices), gl.STATIC_DRAW);\n              var index_buffer = gl.createBuffer();\n              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);\n              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(polygon.triangles), gl.STATIC_DRAW);\n              var outline_position_buffer = gl.createBuffer();\n              gl.bindBuffer(gl.ARRAY_BUFFER, outline_position_buffer);\n              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(polygon.outline_vertices), gl.STATIC_DRAW);\n              var outline_normal_buffer = gl.createBuffer();\n              gl.bindBuffer(gl.ARRAY_BUFFER, outline_normal_buffer);\n              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(polygon.outline_normals), gl.STATIC_DRAW);\n              polygon.gl_position_buffer = position_buffer;\n              polygon.gl_index_buffer = index_buffer;\n              polygon.gl_outline_position_buffer = outline_position_buffer;\n              polygon.gl_outline_normal_buffer = outline_normal_buffer;\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      var handleResize = function handleResize() {\n        canvas.width = canvas.clientWidth;\n        canvas.height = canvas.clientHeight;\n        gl.viewport(0, 0, canvas.width, canvas.height);\n        _this2.current_size = [canvas.width, canvas.height];\n      };\n\n      window.addEventListener(\'resize\', handleResize);\n      handleResize();\n      this.webgl_data = {\n        canvas: canvas,\n        context: gl,\n        fill_data: {\n          shader_program: fill_shader_program,\n          position_attribute: fill_position_attribute,\n          translate_uniform: fill_translate_uniform,\n          scale_uniform: fill_scale_uniform,\n          color_uniform: fill_color_uniform\n        },\n        stroke_data: {\n          shader_program: stroke_shader_program,\n          position_attribute: stroke_position_attribute,\n          normal_attribute: stroke_normal_attribute,\n          translate_uniform: stroke_translate_uniform,\n          scale_uniform: stroke_scale_uniform,\n          scale2_uniform: stroke_scale2_uniform,\n          width_uniform: stroke_width_uniform,\n          color_uniform: stroke_color_uniform\n        }\n      };\n      this.renderMapInCanvas();\n    }\n  }, {\n    key: "disconnectedCallback",\n    value: function disconnectedCallback() {\n      var _this$webgl_data;\n\n      if ((_this$webgl_data = this.webgl_data) === null || _this$webgl_data === void 0 ? void 0 : _this$webgl_data.context) {\n        var gl = this.webgl_data.context;\n\n        var _iterator9 = _createForOfIteratorHelper(this.locations),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var location = _step9.value;\n\n            var _iterator10 = _createForOfIteratorHelper(location_data_cache[location.id].polygons),\n                _step10;\n\n            try {\n              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                var polygon = _step10.value;\n                gl.deleteBuffer(polygon.gl_position_buffer);\n                gl.deleteBuffer(polygon.gl_index_buffer);\n                gl.deleteBuffer(polygon.gl_outline_position_buffer);\n                gl.deleteBuffer(polygon.gl_outline_normal_buffer);\n              }\n            } catch (err) {\n              _iterator10.e(err);\n            } finally {\n              _iterator10.f();\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        gl.getAttachedShaders(this.webgl_data.fill_data.shader_program).forEach(function (s) {\n          gl.deleteShader(s);\n        });\n        gl.deleteProgram(this.webgl_data.fill_data.fill_shader_program);\n        gl.getAttachedShaders(this.webgl_data.stroke_data.shader_program).forEach(function (s) {\n          gl.deleteShader(s);\n        });\n        gl.deleteProgram(this.webgl_data.stroke_data.shader_program);\n      }\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var min = this.locations.filter(function (loc) {\n        return loc;\n      }).map(function (loc) {\n        return loc.min;\n      }).reduce(function (a, b) {\n        return [Math.min(a[0], b[0]), Math.min(a[1], b[1])];\n      });\n      var max = this.locations.filter(function (loc) {\n        return loc;\n      }).map(function (loc) {\n        return loc.max;\n      }).reduce(function (a, b) {\n        return [Math.max(a[0], b[0]), Math.max(a[1], b[1])];\n      });\n      this.min = min;\n      this.max = max;\n      this.locations.forEach(function (loc) {\n        loc.color = loc.color.map(function (el) {\n          return el / 255;\n        });\n\n        if (loc && !location_data_cache[loc.id]) {\n          location_data_cache[loc.id] = {\n            polygons: loc.coords.map(function (poly) {\n              var data = earcut_default.a.flatten(poly);\n              var triangles = earcut_default()(data.vertices, data.holes, data.dimensions);\n              return {\n                coords: poly,\n                vertices: data.vertices,\n                triangles: triangles,\n                outline_vertices: poly.map(function (part) {\n                  return part.reduce(function (arr, coord) {\n                    return arr.concat([coord, coord, coord, coord]);\n                  }, []).concat([part[0], part[0], part[0], part[0]]);\n                }).flat(3),\n                outline_normals: poly.map(function (part) {\n                  return part.reduce(function (arr, coord, i) {\n                    var last = part[(part.length + i - 1) % part.length];\n                    var from_last = [coord[0] - last[0], coord[1] - last[1]];\n                    var next = part[(i + 1) % part.length];\n                    var to_next = [next[0] - coord[0], next[1] - coord[1]];\n                    return arr.concat([[from_last[1], -from_last[0]], [-from_last[1], from_last[0]], [to_next[1], -to_next[0]], [-to_next[1], to_next[0]]]);\n                  }, []).concat(function () {\n                    var coord = part[0];\n                    var last = part[part.length - 1];\n                    var from_last = [coord[0] - last[0], coord[1] - last[1]];\n                    var next = part[1];\n                    var to_next = [next[0] - coord[0], next[1] - coord[1]];\n                    return [[from_last[1], -from_last[0]], [-from_last[1], from_last[0]], [to_next[1], -to_next[0]], [-to_next[1], to_next[0]]];\n                  }());\n                }).flat(3),\n                min: poly.flat().reduce(function (a, b) {\n                  return [Math.min(a[0], b[0]), Math.min(a[1], b[1])];\n                }),\n                max: poly.flat().reduce(function (a, b) {\n                  return [Math.max(a[0], b[0]), Math.max(a[1], b[1])];\n                })\n              };\n            })\n          };\n        }\n      });\n      return Object(lit_element["c" /* html */])(_templateObject2(), this.handleMouseMove, this.handleMouseMove, this.handleMouseOut, this.handleTouchStart, this.handleTouchStart);\n    }\n  }, {\n    key: "center",\n    get: function get() {\n      return this.zoom_center;\n    }\n  }, {\n    key: "scale",\n    get: function get() {\n      return this.zoom_scale;\n    }\n  }]);\n\n  return MapBackendWebGl;\n}(lit_element["a" /* LitElement */]);\n\ncustomElements.define(\'map-backend\', map_backend_webgl_MapBackendWebGl);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFwL3NoYWRlcnMvZmlsbC1mcmFnbWVudC1zaGFkZXIuZ2xzbD8yNzhhIiwid2VicGFjazovLy8uL3NyYy9tYXAvc2hhZGVycy9maWxsLXZlcnRleC1zaGFkZXIuZ2xzbD9iYTNmIiwid2VicGFjazovLy8uL3NyYy9tYXAvc2hhZGVycy9zdHJva2UtZnJhZ21lbnQtc2hhZGVyLmdsc2w/MjYyOCIsIndlYnBhY2s6Ly8vLi9zcmMvbWFwL3NoYWRlcnMvc3Ryb2tlLXZlcnRleC1zaGFkZXIuZ2xzbD81NDY2Iiwid2VicGFjazovLy8uL3NyYy9tYXAvbWFwLWJhY2tlbmQtd2ViZ2wuanM/NmJhNiJdLCJuYW1lcyI6WyJsb2NhdGlvbl9kYXRhX2NhY2hlIiwiTWFwQmFja2VuZFdlYkdsIiwibG9jYXRpb25zIiwidHlwZSIsIkFycmF5IiwiY3NzIiwiem9vbV9zY2FsZSIsInpvb21fY2VudGVyIiwibWluIiwibWF4IiwiY3VycmVudF9ob3ZlciIsImNlbnRlciIsInNjYWxlIiwiY2xpZW50X3BvcyIsIm1hcCIsInNoYWRvd1Jvb3QiLCJnZXRFbGVtZW50QnlJZCIsIm1hcF9wb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJnZW5lcmF0ZVRyYW5zbGF0ZUFuZFNjYWxlIiwiXyIsImNsaWVudF9wb3Nfbm9ybSIsIngiLCJ3aWR0aCIsInkiLCJoZWlnaHQiLCJ0cmFuc2Zvcm0iLCJsb2NhdGlvbl9wb3MiLCJldmVudCIsInBvcyIsImNsaWVudFBvc1RvTG9jYXRpb25Qb3MiLCJjbGllbnRYIiwiY2xpZW50WSIsImxvYyIsImxvY2F0aW9uIiwiaWQiLCJwb2x5Z29ucyIsInBvbHlnb24iLCJpIiwidHJpYW5nbGVzIiwibGVuZ3RoIiwidjEiLCJ2ZXJ0aWNlcyIsInYyIiwidjMiLCJzaWduIiwicDEiLCJwMiIsInAzIiwiZDEiLCJkMiIsImQzIiwiaGFzX25lZyIsImhhc19wb3MiLCJteV9ldmVudCIsIkV2ZW50IiwicG9zaXRpb24iLCJsb2NhdGlvblBvc1RvQ2xpZW50UG9zIiwiZGlzcGF0Y2hFdmVudCIsImhhbmRsZU1vdXNlT3V0IiwidG91Y2hlcyIsImhhbmRsZU1vdXNlTW92ZSIsImN1cnJlbnRfc2l6ZSIsInRyYW5zbGF0ZSIsInN0cm9rZV9zY2FsZSIsImxhc3RfY2VudGVyIiwibGFzdF9zY2FsZSIsImxhc3RfaG92ZXIiLCJsYXN0X3NpemUiLCJnbCIsIndlYmdsX2RhdGEiLCJjb250ZXh0IiwiZmlsbF9kYXRhIiwic3Ryb2tlX2RhdGEiLCJjbGVhckNvbG9yIiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwidXNlUHJvZ3JhbSIsInNoYWRlcl9wcm9ncmFtIiwidW5pZm9ybTJmdiIsInRyYW5zbGF0ZV91bmlmb3JtIiwic2NhbGVfdW5pZm9ybSIsInNjYWxlMl91bmlmb3JtIiwidW5pZm9ybTFmIiwid2lkdGhfdW5pZm9ybSIsInVuaWZvcm0zZnYiLCJjb2xvcl91bmlmb3JtIiwiYmluZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsImdsX291dGxpbmVfcG9zaXRpb25fYnVmZmVyIiwidmVydGV4QXR0cmliUG9pbnRlciIsInBvc2l0aW9uX2F0dHJpYnV0ZSIsIkZMT0FUIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJnbF9vdXRsaW5lX25vcm1hbF9idWZmZXIiLCJub3JtYWxfYXR0cmlidXRlIiwib2Zmc2V0IiwiY29vcmRzIiwicGFydCIsImRyYXdBcnJheXMiLCJUUklBTkdMRV9TVFJJUCIsImNvbG9yIiwiZWwiLCJnbF9wb3NpdGlvbl9idWZmZXIiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsImdsX2luZGV4X2J1ZmZlciIsImRyYXdFbGVtZW50cyIsIlRSSUFOR0xFUyIsIlVOU0lHTkVEX1NIT1JUIiwid2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVuZGVyTWFwSW5DYW52YXMiLCJiaW5kIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsImNyZWF0ZVNoYWRlclByb2dyYW0iLCJ2ZXJ0ZXhfc2hhZGVyX3NvdXJjZSIsImZyYWdtZW50X3NoYWRlcl9zb3VyY2UiLCJ2ZXJ0ZXhfc2hhZGVyIiwiY3JlYXRlU2hhZGVyIiwiVkVSVEVYX1NIQURFUiIsInNoYWRlclNvdXJjZSIsImNvbXBpbGVTaGFkZXIiLCJmcmFnbWVudF9zaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJjcmVhdGVQcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJmaWxsX3NoYWRlcl9wcm9ncmFtIiwiRmlsbFZlcnRleFNoYWRlciIsIkZpbGxGcmFnbWVudFNoYWRlciIsImZpbGxfcG9zaXRpb25fYXR0cmlidXRlIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJmaWxsX3RyYW5zbGF0ZV91bmlmb3JtIiwiZ2V0VW5pZm9ybUxvY2F0aW9uIiwiZmlsbF9zY2FsZV91bmlmb3JtIiwiZmlsbF9jb2xvcl91bmlmb3JtIiwic3Ryb2tlX3NoYWRlcl9wcm9ncmFtIiwiU3Ryb2tlVmVydGV4U2hhZGVyIiwiU3Ryb2tlRnJhZ21lbnRTaGFkZXIiLCJzdHJva2VfcG9zaXRpb25fYXR0cmlidXRlIiwic3Ryb2tlX25vcm1hbF9hdHRyaWJ1dGUiLCJzdHJva2VfdHJhbnNsYXRlX3VuaWZvcm0iLCJzdHJva2Vfc2NhbGVfdW5pZm9ybSIsInN0cm9rZV9zY2FsZTJfdW5pZm9ybSIsInN0cm9rZV93aWR0aF91bmlmb3JtIiwic3Ryb2tlX2NvbG9yX3VuaWZvcm0iLCJwb3NpdGlvbl9idWZmZXIiLCJjcmVhdGVCdWZmZXIiLCJidWZmZXJEYXRhIiwiRmxvYXQzMkFycmF5IiwiU1RBVElDX0RSQVciLCJpbmRleF9idWZmZXIiLCJVaW50MTZBcnJheSIsIm91dGxpbmVfcG9zaXRpb25fYnVmZmVyIiwib3V0bGluZV92ZXJ0aWNlcyIsIm91dGxpbmVfbm9ybWFsX2J1ZmZlciIsIm91dGxpbmVfbm9ybWFscyIsImhhbmRsZVJlc2l6ZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwidmlld3BvcnQiLCJhZGRFdmVudExpc3RlbmVyIiwiZGVsZXRlQnVmZmVyIiwiZ2V0QXR0YWNoZWRTaGFkZXJzIiwiZm9yRWFjaCIsInMiLCJkZWxldGVTaGFkZXIiLCJkZWxldGVQcm9ncmFtIiwiZmlsdGVyIiwicmVkdWNlIiwiYSIsImIiLCJNYXRoIiwicG9seSIsImRhdGEiLCJlYXJjdXQiLCJmbGF0dGVuIiwiaG9sZXMiLCJkaW1lbnNpb25zIiwiYXJyIiwiY29vcmQiLCJjb25jYXQiLCJmbGF0IiwibGFzdCIsImZyb21fbGFzdCIsIm5leHQiLCJ0b19uZXh0IiwiaHRtbCIsImhhbmRsZVRvdWNoU3RhcnQiLCJMaXRFbGVtZW50IiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFlLG9HQUEyQyx3Q0FBd0MsaUJBQWlCLDJDQUEyQyxHQUFHLEdBQUcsRTs7QUNBckoseUZBQWtDLDRCQUE0QixzQkFBc0IsaUJBQWlCLDRFQUE0RSxHQUFHLEdBQUcsRTs7QUNBdkwsc0dBQTJDLDBDQUEwQyxpQkFBaUIsNkNBQTZDLEdBQUcsT0FBTyxFOztBQ0E3SiwyRkFBa0MsK0JBQStCLDRCQUE0QixzQkFBc0IsNEJBQTRCLHVCQUF1QixpQkFBaUIsa0pBQWtKLEdBQUcsR0FBRyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQzlWO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBTUEsbUJBQW1CLEdBQUcsRUFBNUI7O0lBRU1DLGlDOzs7Ozs7O3dCQUVzQjtBQUNwQixhQUFPO0FBQ0hDLGlCQUFTLEVBQUU7QUFBRUMsY0FBSSxFQUFFQztBQUFSO0FBRFIsT0FBUDtBQUdIOzs7d0JBRW1CO0FBQ2hCLGFBQU9DLGtDQUFQO0FBZ0JIOzs7QUFFRCw2QkFBYztBQUFBOztBQUFBOztBQUNWO0FBQ0EsVUFBS0MsVUFBTCxHQUFrQixDQUFsQjtBQUNBLFVBQUtDLFdBQUwsR0FBbUIsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFu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UyxJQUFMLEdBQVliLE1BQVosQ0FBbUIsVUFBQ0MsQ0FBRCxFQUFJQyxDQUFKO0FBQUEseUJBQVUsQ0FBQ0MsSUFBSSxDQUFDcEssR0FBTCxDQUFTa0ssQ0FBQyxDQUFDLENBQUQsQ0FBVixFQUFlQyxDQUFDLENBQUMsQ0FBRCxDQUFoQixDQUFELEVBQXVCQyxJQUFJLENBQUNwSyxHQUFMLENBQVNrSyxDQUFDLENBQUMsQ0FBRCxDQUFWLEVBQWVDLENBQUMsQ0FBQyxDQUFELENBQWhCLENBQXZCLENBQVY7QUFBQSxpQkFBbkI7QUFuQ0YsZUFBUDtBQXFDSCxhQXhDUztBQURnQixXQUE5QjtBQTJDSDtBQUNKLE9BL0NEO0FBZ0RBLGFBQU9nQixtQ0FBUCxxQkFHc0IsS0FBSy9ILGVBSDNCLEVBSWtCLEtBQUtBLGVBSnZCLEVBS3FCLEtBQUtGLGNBTDFCLEVBTXVCLEtBQUtrSSxnQkFONUIsRUFPc0IsS0FBS0EsZ0JBUDNCO0FBV0g7Ozt3QkE1WVk7QUFDVCxhQUFPLEtBQUt0TCxXQUFaO0FBQ0g7Ozt3QkFFVztBQUNSLGFBQU8sS0FBS0QsVUFBWjtBQUNIOzs7O0VBMUN5QndMLGlDOztBQW9iOUJDLGNBQWMsQ0FBQ0MsTUFBZixDQUFzQixhQUF0QixFQUFxQy9MLGlDQUFyQyIsImZpbGUiOiI1MC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiXFxuI2lmZGVmIEdMX0VTXFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG4gICAgXFxudW5pZm9ybSB2ZWMzIHVGaWxsQ29sb3I7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVGaWxsQ29sb3IsIDEuMCk7XFxufVxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiXFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcblxcbnVuaWZvcm0gdmVjMiB1VHJhbnNsYXRlO1xcbnVuaWZvcm0gdmVjMiB1U2NhbGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKGFWZXJ0ZXhQb3NpdGlvbiArIHVUcmFuc2xhdGUpICogdVNjYWxlLCAwLjAsIDEuMCk7XFxufVxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiXFxuI2lmZGVmIEdMX0VTXFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG4gICAgXFxudW5pZm9ybSB2ZWMzIHVTdHJva2VDb2xvcjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodVN0cm9rZUNvbG9yLCAxLjApO1xcbn1cXG4gICAgXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCJcXG5hdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleE5vcm1hbDtcXG5cXG51bmlmb3JtIHZlYzIgdVRyYW5zbGF0ZTtcXG51bmlmb3JtIHZlYzIgdVNjYWxlO1xcbnVuaWZvcm0gdmVjMiB1U3Ryb2tlU2NhbGU7XFxudW5pZm9ybSBmbG9hdCB1V2lkdGg7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoXFxuICAgICAgICAoYVZlcnRleFBvc2l0aW9uICsgdVRyYW5zbGF0ZSkgKiB1U2NhbGUgKyBub3JtYWxpemUoYVZlcnRleE5vcm1hbCkgKiB1V2lkdGggKiB1U3Ryb2tlU2NhbGUsXFxuICAgICAgICAwLjAsIDEuMCk7XFxufVxcblwiOyIsIlxuaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCwgY3NzIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xuaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnO1xuXG5pbXBvcnQgeyBtYXAgfSBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IEZpbGxGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlcnMvZmlsbC1mcmFnbWVudC1zaGFkZXIuZ2xzbCc7XG5pbXBvcnQgRmlsbFZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlcnMvZmlsbC12ZXJ0ZXgtc2hhZGVyLmdsc2wnO1xuaW1wb3J0IFN0cm9rZUZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVycy9zdHJva2UtZnJhZ21lbnQtc2hhZGVyLmdsc2wnO1xuaW1wb3J0IFN0cm9rZVZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlcnMvc3Ryb2tlLXZlcnRleC1zaGFkZXIuZ2xzbCc7XG5cbmNvbnN0IGxvY2F0aW9uX2RhdGFfY2FjaGUgPSB7fTtcblxuY2xhc3MgTWFwQmFja2VuZFdlYkdsIGV4dGVuZHMgTGl0RWxlbWVudCB7XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhdGlvbnM6IHsgdHlwZTogQXJyYXkgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBzdHlsZXMoKSB7XG4gICAgICAgIHJldHVybiBjc3NgXG4gICAgICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICNtYXAge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgICAgICAgICAgICAgbWF4LWhlaWdodDogMTAwJTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnpvb21fc2NhbGUgPSAxO1xuICAgICAgICB0aGlzLnpvb21fY2VudGVyID0gWzAsIDBdO1xuICAgICAgICB0aGlzLm1pbiA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5tYXggPSBbMCwgMF07XG4gICAgICAgIHRoaXMuY3VycmVudF9ob3ZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IGNlbnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9vbV9jZW50ZXI7XG4gICAgfVxuXG4gICAgZ2V0IHNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy56b29tX3NjYWxlO1xuICAgIH1cblxuICAgIHNldENlbnRlckFuZFNjYWxlKGNlbnRlciwgc2NhbGUpIHtcbiAgICAgICAgdGhpcy56b29tX2NlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgdGhpcy56b29tX3NjYWxlID0gc2NhbGU7XG4gICAgfVxuICAgIFxuICAgIGNsaWVudFBvc1RvTWFwUG9zKGNsaWVudF9wb3MpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdtYXAnKTtcbiAgICAgICAgY29uc3QgbWFwX3BvcyA9IG1hcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgW18sIHNjYWxlXSA9IHRoaXMuZ2VuZXJhdGVUcmFuc2xhdGVBbmRTY2FsZSgpO1xuICAgICAgICBjb25zdCBjbGllbnRfcG9zX25vcm0gPSBbXG4gICAgICAgICAgICAyICogKGNsaWVudF9wb3NbMF0gLSBtYXBfcG9zLngpIC8gbWFwX3Bvcy53aWR0aCAtIDEuMCxcbiAgICAgICAgICAgIDEuMCAtIDIgKiAoY2xpZW50X3Bvc1sxXSAtIG1hcF9wb3MueSkgLyBtYXBfcG9zLmhlaWdodCxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGNsaWVudF9wb3Nfbm9ybVswXSAvIHNjYWxlWzBdICsgdGhpcy56b29tX2NlbnRlclswXSxcbiAgICAgICAgICAgIGNsaWVudF9wb3Nfbm9ybVsxXSAvIHNjYWxlWzFdICsgdGhpcy56b29tX2NlbnRlclsxXSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBjbGllbnRQb3NUb0xvY2F0aW9uUG9zKGNsaWVudF9wb3MpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdtYXAnKTtcbiAgICAgICAgY29uc3QgbWFwX3BvcyA9IG1hcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgW3RyYW5zZm9ybSwgc2NhbGVdID0gdGhpcy5nZW5lcmF0ZVRyYW5zbGF0ZUFuZFNjYWxlKCk7XG4gICAgICAgIGNvbnN0IGNsaWVudF9wb3Nfbm9ybSA9IFtcbiAgICAgICAgICAgIDIgKiAoY2xpZW50X3Bvc1swXSAtIG1hcF9wb3MueCkgLyBtYXBfcG9zLndpZHRoIC0gMS4wLFxuICAgICAgICAgICAgMS4wIC0gMiAqIChjbGllbnRfcG9zWzFdIC0gbWFwX3Bvcy55KSAvIG1hcF9wb3MuaGVpZ2h0LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY2xpZW50X3Bvc19ub3JtWzBdIC8gc2NhbGVbMF0gLSB0cmFuc2Zvcm1bMF0sXG4gICAgICAgICAgICBjbGllbnRfcG9zX25vcm1bMV0gLyBzY2FsZVsxXSAtIHRyYW5zZm9ybVsxXSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgXG4gICAgbG9jYXRpb25Qb3NUb0NsaWVudFBvcyhsb2NhdGlvbl9wb3MpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdtYXAnKTtcbiAgICAgICAgY29uc3QgbWFwX3BvcyA9IG1hcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgW3RyYW5zZm9ybSwgc2NhbGVdID0gdGhpcy5nZW5lcmF0ZVRyYW5zbGF0ZUFuZFNjYWxlKCk7XG4gICAgICAgIGNvbnN0IGNsaWVudF9wb3Nfbm9ybSA9IFtcbiAgICAgICAgICAgIChsb2NhdGlvbl9wb3NbMF0gKyB0cmFuc2Zvcm1bMF0pICogc2NhbGVbMF0sXG4gICAgICAgICAgICAobG9jYXRpb25fcG9zWzFdICsgdHJhbnNmb3JtWzFdKSAqIHNjYWxlWzFdLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKGNsaWVudF9wb3Nfbm9ybVswXSArIDEuMCkgLyAyICogbWFwX3Bvcy53aWR0aCArIG1hcF9wb3MueCxcbiAgICAgICAgICAgICgxLjAgLSBjbGllbnRfcG9zX25vcm1bMV0pIC8gMiAqIG1hcF9wb3MuaGVpZ2h0ICsgbWFwX3Bvcy55LFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmNsaWVudFBvc1RvTG9jYXRpb25Qb3MoW2V2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFldKTtcbiAgICAgICAgZm9yKGNvbnN0IGxvYyBvZiB0aGlzLmxvY2F0aW9ucykge1xuICAgICAgICAgICAgaWYobG9jLm1pblswXSA8PSBwb3NbMF0gJiYgbG9jLm1pblsxXSA8PSBwb3NbMV0gJiZcbiAgICAgICAgICAgICAgICBsb2MubWF4WzBdID49IHBvc1swXSAmJiBsb2MubWF4WzFdID49IHBvc1sxXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gbG9jYXRpb25fZGF0YV9jYWNoZVtsb2MuaWRdO1xuICAgICAgICAgICAgICAgIGZvcihjb25zdCBwb2x5Z29uIG9mIGxvY2F0aW9uLnBvbHlnb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHBvbHlnb24ubWluWzBdIDw9IHBvc1swXSAmJiBwb2x5Z29uLm1pblsxXSA8PSBwb3NbMV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24ubWF4WzBdID49IHBvc1swXSAmJiBwb2x5Z29uLm1heFsxXSA+PSBwb3NbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLnRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnZlcnRpY2VzWzIgKiBwb2x5Z29uLnRyaWFuZ2xlc1tpXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24udmVydGljZXNbMiAqIHBvbHlnb24udHJpYW5nbGVzW2ldICsgMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYyID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnZlcnRpY2VzWzIgKiBwb2x5Z29uLnRyaWFuZ2xlc1tpICsgMV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnZlcnRpY2VzWzIgKiBwb2x5Z29uLnRyaWFuZ2xlc1tpICsgMV0gKyAxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdjMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24udmVydGljZXNbMiAqIHBvbHlnb24udHJpYW5nbGVzW2kgKyAyXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24udmVydGljZXNbMiAqIHBvbHlnb24udHJpYW5nbGVzW2kgKyAyXSArIDFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaWduKHAxLCBwMiwgcDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwMVswXSAtIHAzWzBdKSAqIChwMlsxXSAtIHAzWzFdKSAtIChwMlswXSAtIHAzWzBdKSAqIChwMVsxXSAtIHAzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZDEgPSBzaWduKHBvcywgdjEsIHYyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkMiA9IHNpZ24ocG9zLCB2MiwgdjMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQzID0gc2lnbihwb3MsIHYzLCB2MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzX25lZyA9IChkMSA8IDApIHx8IChkMiA8IDApIHx8IChkMyA8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc19wb3MgPSAoZDEgPiAwKSB8fCAoZDIgPiAwKSB8fCAoZDMgPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighKGhhc19uZWcgJiYgaGFzX3BvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50X2hvdmVyID0gbG9jLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBteV9ldmVudCA9IG5ldyBFdmVudCgnaG92ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXlfZXZlbnQubG9jYXRpb24gPSBsb2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG15X2V2ZW50LnBvc2l0aW9uID0gdGhpcy5sb2NhdGlvblBvc1RvQ2xpZW50UG9zKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwb2x5Z29uLm1pblswXSArIHBvbHlnb24ubWF4WzBdKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocG9seWdvbi5taW5bMV0gKyBwb2x5Z29uLm1heFsxXSkgLyAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobXlfZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VPdXQoKTtcbiAgICB9XG5cbiAgICBoYW5kbGVNb3VzZU91dCgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50X2hvdmVyID0gbnVsbDtcbiAgICAgICAgY29uc3QgbXlfZXZlbnQgPSBuZXcgRXZlbnQoJ2hvdmVyJyk7XG4gICAgICAgIG15X2V2ZW50LmxvY2F0aW9uID0gbnVsbDtcbiAgICAgICAgbXlfZXZlbnQucG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobXlfZXZlbnQpO1xuICAgIH1cbiAgICBcbiAgICBoYW5kbGVUb3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICAgIGlmKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlTW92ZSh7XG4gICAgICAgICAgICAgICAgY2xpZW50WDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZU91dChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZ2VuZXJhdGVUcmFuc2xhdGVBbmRTY2FsZSgpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLm1heFswXSAtIHRoaXMubWluWzBdO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLm1heFsxXSAtIHRoaXMubWluWzFdO1xuICAgICAgICBpZih3aWR0aCAvIHRoaXMuY3VycmVudF9zaXplWzBdID4gaGVpZ2h0IC8gdGhpcy5jdXJyZW50X3NpemVbMV0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAtdGhpcy5taW5bMF0gLSB3aWR0aCAvIDIgLSB0aGlzLnpvb21fY2VudGVyWzBdLFxuICAgICAgICAgICAgICAgIC10aGlzLm1pblsxXSAtIGhlaWdodCAvIDIgLSB0aGlzLnpvb21fY2VudGVyWzFdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gW1xuICAgICAgICAgICAgICAgIDIgLyB3aWR0aCAqIHRoaXMuem9vbV9zY2FsZSxcbiAgICAgICAgICAgICAgICAtMiAqICh0aGlzLmN1cnJlbnRfc2l6ZVswXSAvIHRoaXMuY3VycmVudF9zaXplWzFdKSAvIHdpZHRoICogdGhpcy56b29tX3NjYWxlLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZV9zY2FsZSA9IFtcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgIC10aGlzLmN1cnJlbnRfc2l6ZVswXSAvIHRoaXMuY3VycmVudF9zaXplWzFdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBbdHJhbnNsYXRlLCBzY2FsZSwgc3Ryb2tlX3NjYWxlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAtdGhpcy5taW5bMF0gLSB3aWR0aCAvIDIgLSB0aGlzLnpvb21fY2VudGVyWzBdLFxuICAgICAgICAgICAgICAgIC10aGlzLm1pblsxXSAtIGhlaWdodCAvIDIgLSB0aGlzLnpvb21fY2VudGVyWzFdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gW1xuICAgICAgICAgICAgICAgIDIgKiAodGhpcy5jdXJyZW50X3NpemVbMV0gLyB0aGlzLmN1cnJlbnRfc2l6ZVswXSkgLyBoZWlnaHQgKiB0aGlzLnpvb21fc2NhbGUsXG4gICAgICAgICAgICAgICAgLTIgLyAgaGVpZ2h0ICogdGhpcy56b29tX3NjYWxlLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZV9zY2FsZSA9IFtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRfc2l6ZVsxXSAvIHRoaXMuY3VycmVudF9zaXplWzBdLFxuICAgICAgICAgICAgICAgIC0xLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBbdHJhbnNsYXRlLCBzY2FsZSwgc3Ryb2tlX3NjYWxlXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlck1hcEluQ2FudmFzKCkge1xuICAgICAgICBpZiAodGhpcy5sYXN0X2NlbnRlciAhPSB0aGlzLnpvb21fY2VudGVyXG4gICAgICAgICAgICB8fCB0aGlzLmxhc3Rfc2NhbGUgIT0gdGhpcy56b29tX3NjYWxlXG4gICAgICAgICAgICB8fCB0aGlzLmxhc3RfaG92ZXIgIT0gdGhpcy5jdXJyZW50X2hvdmVyXG4gICAgICAgICAgICB8fCB0aGlzLmxhc3Rfc2l6ZSAhPSB0aGlzLmN1cnJlbnRfc2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLndlYmdsX2RhdGEuY29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IGZpbGxfZGF0YSA9IHRoaXMud2ViZ2xfZGF0YS5maWxsX2RhdGE7XG4gICAgICAgICAgICBjb25zdCBzdHJva2VfZGF0YSA9IHRoaXMud2ViZ2xfZGF0YS5zdHJva2VfZGF0YTtcblxuICAgICAgICAgICAgY29uc3QgW3RyYW5zbGF0ZSwgc2NhbGUsIHN0cm9rZV9zY2FsZV0gPSB0aGlzLmdlbmVyYXRlVHJhbnNsYXRlQW5kU2NhbGUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcihjb25zdCBsb2Mgb2YgdGhpcy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGxvY2F0aW9uX2RhdGFfY2FjaGVbbG9jLmlkXTtcbiAgICAgICAgICAgICAgICAvLyBEcmF3IHN0cm9rZVxuICAgICAgICAgICAgICAgIGdsLnVzZVByb2dyYW0oc3Ryb2tlX2RhdGEuc2hhZGVyX3Byb2dyYW0pO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZnYoc3Ryb2tlX2RhdGEudHJhbnNsYXRlX3VuaWZvcm0sIHRyYW5zbGF0ZSk7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihzdHJva2VfZGF0YS5zY2FsZV91bmlmb3JtLCBzY2FsZSk7XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihzdHJva2VfZGF0YS5zY2FsZTJfdW5pZm9ybSwgc3Ryb2tlX3NjYWxlKTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYoc3Ryb2tlX2RhdGEud2lkdGhfdW5pZm9ybSwgMC4wMDUpO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYoc3Ryb2tlX2RhdGEuY29sb3JfdW5pZm9ybSwgWzAuMjcxLCAwLjMwMiwgMC4zOF0pO1xuICAgICAgICAgICAgICAgIGZvcihjb25zdCBwb2x5Z29uIG9mIGxvY2F0aW9uLnBvbHlnb25zKSB7ICAgIFxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcG9seWdvbi5nbF9vdXRsaW5lX3Bvc2l0aW9uX2J1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc3Ryb2tlX2RhdGEucG9zaXRpb25fYXR0cmlidXRlLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzdHJva2VfZGF0YS5wb3NpdGlvbl9hdHRyaWJ1dGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwb2x5Z29uLmdsX291dGxpbmVfbm9ybWFsX2J1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc3Ryb2tlX2RhdGEubm9ybWFsX2F0dHJpYnV0ZSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoc3Ryb2tlX2RhdGEubm9ybWFsX2F0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGNvbnN0IHBhcnQgb2YgcG9seWdvbi5jb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIG9mZnNldCAqIDQsIChwYXJ0Lmxlbmd0aCArIDEpICogNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gcGFydC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERyYXcgZmlsbFxuICAgICAgICAgICAgICAgIGdsLnVzZVByb2dyYW0oZmlsbF9kYXRhLnNoYWRlcl9wcm9ncmFtKTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmZ2KGZpbGxfZGF0YS50cmFuc2xhdGVfdW5pZm9ybSwgdHJhbnNsYXRlKTtcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmZ2KGZpbGxfZGF0YS5zY2FsZV91bmlmb3JtLCBzY2FsZSk7XG4gICAgICAgICAgICAgICAgaWYobG9jLmlkID09PSB0aGlzLmN1cnJlbnRfaG92ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTNmdihmaWxsX2RhdGEuY29sb3JfdW5pZm9ybSwgbG9jLmNvbG9yLm1hcChlbCA9PiBlbCAqIDAuOCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0zZnYoZmlsbF9kYXRhLmNvbG9yX3VuaWZvcm0sIGxvYy5jb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcihjb25zdCBwb2x5Z29uIG9mIGxvY2F0aW9uLnBvbHlnb25zKSB7ICAgIFxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcG9seWdvbi5nbF9wb3NpdGlvbl9idWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGZpbGxfZGF0YS5wb3NpdGlvbl9hdHRyaWJ1dGUsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGZpbGxfZGF0YS5wb3NpdGlvbl9hdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgcG9seWdvbi5nbF9pbmRleF9idWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgcG9seWdvbi50cmlhbmdsZXMubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXN0X2NlbnRlciA9IHRoaXMuem9vbV9jZW50ZXI7XG4gICAgICAgICAgICB0aGlzLmxhc3Rfc2NhbGUgPSB0aGlzLnpvb21fc2NhbGU7XG4gICAgICAgICAgICB0aGlzLmxhc3RfaG92ZXIgPSB0aGlzLmN1cnJlbnRfaG92ZXI7XG4gICAgICAgICAgICB0aGlzLmxhc3Rfc2l6ZSA9IHRoaXMuY3VycmVudF9zaXplO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXJNYXBJbkNhbnZhcy5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmaXJzdFVwZGF0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbWFwJyk7XG4gICAgICAgIHRoaXMuY3VycmVudF9zaXplID0gW2NhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodF07XG4gICAgICAgIGNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2hhZGVyUHJvZ3JhbSh2ZXJ0ZXhfc2hhZGVyX3NvdXJjZSwgZnJhZ21lbnRfc2hhZGVyX3NvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgdmVydGV4X3NoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcbiAgICAgICAgICAgIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhfc2hhZGVyLCB2ZXJ0ZXhfc2hhZGVyX3NvdXJjZSk7XG4gICAgICAgICAgICBnbC5jb21waWxlU2hhZGVyKHZlcnRleF9zaGFkZXIpO1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnRfc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgICAgICAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRfc2hhZGVyLCBmcmFnbWVudF9zaGFkZXJfc291cmNlKTtcbiAgICAgICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRfc2hhZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlcl9wcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlcl9wcm9ncmFtLCB2ZXJ0ZXhfc2hhZGVyKTtcbiAgICAgICAgICAgIGdsLmF0dGFjaFNoYWRlcihzaGFkZXJfcHJvZ3JhbSwgZnJhZ21lbnRfc2hhZGVyKTtcbiAgICAgICAgICAgIGdsLmxpbmtQcm9ncmFtKHNoYWRlcl9wcm9ncmFtKTtcbiAgICAgICAgICAgIHJldHVybiBzaGFkZXJfcHJvZ3JhbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGxfc2hhZGVyX3Byb2dyYW0gPSBjcmVhdGVTaGFkZXJQcm9ncmFtKEZpbGxWZXJ0ZXhTaGFkZXIsIEZpbGxGcmFnbWVudFNoYWRlcik7XG4gICAgICAgIGNvbnN0IGZpbGxfcG9zaXRpb25fYXR0cmlidXRlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oZmlsbF9zaGFkZXJfcHJvZ3JhbSwgJ2FWZXJ0ZXhQb3NpdGlvbicpO1xuICAgICAgICBjb25zdCBmaWxsX3RyYW5zbGF0ZV91bmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGZpbGxfc2hhZGVyX3Byb2dyYW0sICd1VHJhbnNsYXRlJyk7XG4gICAgICAgIGNvbnN0IGZpbGxfc2NhbGVfdW5pZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihmaWxsX3NoYWRlcl9wcm9ncmFtLCAndVNjYWxlJyk7XG4gICAgICAgIGNvbnN0IGZpbGxfY29sb3JfdW5pZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihmaWxsX3NoYWRlcl9wcm9ncmFtLCAndUZpbGxDb2xvcicpO1xuXG4gICAgICAgIGNvbnN0IHN0cm9rZV9zaGFkZXJfcHJvZ3JhbSA9IGNyZWF0ZVNoYWRlclByb2dyYW0oU3Ryb2tlVmVydGV4U2hhZGVyLCBTdHJva2VGcmFnbWVudFNoYWRlcik7XG4gICAgICAgIGNvbnN0IHN0cm9rZV9wb3NpdGlvbl9hdHRyaWJ1dGUgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihzdHJva2Vfc2hhZGVyX3Byb2dyYW0sICdhVmVydGV4UG9zaXRpb24nKTtcbiAgICAgICAgY29uc3Qgc3Ryb2tlX25vcm1hbF9hdHRyaWJ1dGUgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihzdHJva2Vfc2hhZGVyX3Byb2dyYW0sICdhVmVydGV4Tm9ybWFsJyk7XG4gICAgICAgIGNvbnN0IHN0cm9rZV90cmFuc2xhdGVfdW5pZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzdHJva2Vfc2hhZGVyX3Byb2dyYW0sICd1VHJhbnNsYXRlJyk7XG4gICAgICAgIGNvbnN0IHN0cm9rZV9zY2FsZV91bmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHN0cm9rZV9zaGFkZXJfcHJvZ3JhbSwgJ3VTY2FsZScpO1xuICAgICAgICBjb25zdCBzdHJva2Vfc2NhbGUyX3VuaWZvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc3Ryb2tlX3NoYWRlcl9wcm9ncmFtLCAndVN0cm9rZVNjYWxlJyk7XG4gICAgICAgIGNvbnN0IHN0cm9rZV93aWR0aF91bmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHN0cm9rZV9zaGFkZXJfcHJvZ3JhbSwgJ3VXaWR0aCcpO1xuICAgICAgICBjb25zdCBzdHJva2VfY29sb3JfdW5pZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzdHJva2Vfc2hhZGVyX3Byb2dyYW0sICd1U3Ryb2tlQ29sb3InKTtcblxuICAgICAgICBmb3IoY29uc3QgbG9jYXRpb24gb2YgdGhpcy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICAgIGZvcihjb25zdCBwb2x5Z29uIG9mIGxvY2F0aW9uX2RhdGFfY2FjaGVbbG9jYXRpb24uaWRdLnBvbHlnb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25fYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uX2J1ZmZlcik7XG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkocG9seWdvbi52ZXJ0aWNlcyksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleF9idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleF9idWZmZXIpO1xuICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG5ldyBVaW50MTZBcnJheShwb2x5Z29uLnRyaWFuZ2xlcyksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRsaW5lX3Bvc2l0aW9uX2J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBvdXRsaW5lX3Bvc2l0aW9uX2J1ZmZlcik7XG4gICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkocG9seWdvbi5vdXRsaW5lX3ZlcnRpY2VzKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dGxpbmVfbm9ybWFsX2J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBvdXRsaW5lX25vcm1hbF9idWZmZXIpO1xuICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHBvbHlnb24ub3V0bGluZV9ub3JtYWxzKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgICAgICAgIHBvbHlnb24uZ2xfcG9zaXRpb25fYnVmZmVyID0gcG9zaXRpb25fYnVmZmVyO1xuICAgICAgICAgICAgICAgIHBvbHlnb24uZ2xfaW5kZXhfYnVmZmVyID0gaW5kZXhfYnVmZmVyO1xuICAgICAgICAgICAgICAgIHBvbHlnb24uZ2xfb3V0bGluZV9wb3NpdGlvbl9idWZmZXIgPSBvdXRsaW5lX3Bvc2l0aW9uX2J1ZmZlcjtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLmdsX291dGxpbmVfbm9ybWFsX2J1ZmZlciA9IG91dGxpbmVfbm9ybWFsX2J1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50X3NpemUgPSBbY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0XTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICAgICAgaGFuZGxlUmVzaXplKCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLndlYmdsX2RhdGEgPSB7XG4gICAgICAgICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgICAgICAgIGNvbnRleHQ6IGdsLFxuICAgICAgICAgICAgZmlsbF9kYXRhOiB7XG4gICAgICAgICAgICAgICAgc2hhZGVyX3Byb2dyYW06IGZpbGxfc2hhZGVyX3Byb2dyYW0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25fYXR0cmlidXRlOiBmaWxsX3Bvc2l0aW9uX2F0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVfdW5pZm9ybTogZmlsbF90cmFuc2xhdGVfdW5pZm9ybSxcbiAgICAgICAgICAgICAgICBzY2FsZV91bmlmb3JtOiBmaWxsX3NjYWxlX3VuaWZvcm0sXG4gICAgICAgICAgICAgICAgY29sb3JfdW5pZm9ybTogZmlsbF9jb2xvcl91bmlmb3JtLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cm9rZV9kYXRhOiB7XG4gICAgICAgICAgICAgICAgc2hhZGVyX3Byb2dyYW06IHN0cm9rZV9zaGFkZXJfcHJvZ3JhbSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbl9hdHRyaWJ1dGU6IHN0cm9rZV9wb3NpdGlvbl9hdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgbm9ybWFsX2F0dHJpYnV0ZTogc3Ryb2tlX25vcm1hbF9hdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlX3VuaWZvcm06IHN0cm9rZV90cmFuc2xhdGVfdW5pZm9ybSxcbiAgICAgICAgICAgICAgICBzY2FsZV91bmlmb3JtOiBzdHJva2Vfc2NhbGVfdW5pZm9ybSxcbiAgICAgICAgICAgICAgICBzY2FsZTJfdW5pZm9ybTogc3Ryb2tlX3NjYWxlMl91bmlmb3JtLFxuICAgICAgICAgICAgICAgIHdpZHRoX3VuaWZvcm06IHN0cm9rZV93aWR0aF91bmlmb3JtLFxuICAgICAgICAgICAgICAgIGNvbG9yX3VuaWZvcm06IHN0cm9rZV9jb2xvcl91bmlmb3JtLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW5kZXJNYXBJbkNhbnZhcygpO1xuICAgIH1cblxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBpZiAodGhpcy53ZWJnbF9kYXRhPy5jb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMud2ViZ2xfZGF0YS5jb250ZXh0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBsb2NhdGlvbiBvZiB0aGlzLmxvY2F0aW9ucykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9seWdvbiBvZiBsb2NhdGlvbl9kYXRhX2NhY2hlW2xvY2F0aW9uLmlkXS5wb2x5Z29ucykge1xuICAgICAgICAgICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIocG9seWdvbi5nbF9wb3NpdGlvbl9idWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIocG9seWdvbi5nbF9pbmRleF9idWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIocG9seWdvbi5nbF9vdXRsaW5lX3Bvc2l0aW9uX2J1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcihwb2x5Z29uLmdsX291dGxpbmVfbm9ybWFsX2J1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wuZ2V0QXR0YWNoZWRTaGFkZXJzKHRoaXMud2ViZ2xfZGF0YS5maWxsX2RhdGEuc2hhZGVyX3Byb2dyYW0pLmZvckVhY2gocyA9PiB7XG4gICAgICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHRoaXMud2ViZ2xfZGF0YS5maWxsX2RhdGEuZmlsbF9zaGFkZXJfcHJvZ3JhbSk7XG4gICAgICAgICAgICBnbC5nZXRBdHRhY2hlZFNoYWRlcnModGhpcy53ZWJnbF9kYXRhLnN0cm9rZV9kYXRhLnNoYWRlcl9wcm9ncmFtKS5mb3JFYWNoKHMgPT4ge1xuICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcihzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLndlYmdsX2RhdGEuc3Ryb2tlX2RhdGEuc2hhZGVyX3Byb2dyYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5sb2NhdGlvbnMuZmlsdGVyKGxvYyA9PiBsb2MpLm1hcChsb2MgPT4gbG9jLm1pbikucmVkdWNlKChhLCBiKSA9PiBbTWF0aC5taW4oYVswXSwgYlswXSksIE1hdGgubWluKGFbMV0sIGJbMV0pXSk7XG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMubG9jYXRpb25zLmZpbHRlcihsb2MgPT4gbG9jKS5tYXAobG9jID0+IGxvYy5tYXgpLnJlZHVjZSgoYSwgYikgPT4gW01hdGgubWF4KGFbMF0sIGJbMF0pLCBNYXRoLm1heChhWzFdLCBiWzFdKV0pO1xuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIHRoaXMubG9jYXRpb25zLmZvckVhY2gobG9jID0+IHtcbiAgICAgICAgICAgIGxvYy5jb2xvciA9IGxvYy5jb2xvci5tYXAoZWwgPT4gZWwgLyAyNTUpO1xuICAgICAgICAgICAgaWYobG9jICYmICFsb2NhdGlvbl9kYXRhX2NhY2hlW2xvYy5pZF0pIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbl9kYXRhX2NhY2hlW2xvYy5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25zOiBsb2MuY29vcmRzLm1hcChwb2x5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlYXJjdXQuZmxhdHRlbihwb2x5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlcyA9IGVhcmN1dChkYXRhLnZlcnRpY2VzLCBkYXRhLmhvbGVzLCBkYXRhLmRpbWVuc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZHM6IHBvbHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXM6IGRhdGEudmVydGljZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGVzOiB0cmlhbmdsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZV92ZXJ0aWNlczogcG9seS5tYXAocGFydCA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQucmVkdWNlKChhcnIsY29vcmQpID0+IGFyci5jb25jYXQoW2Nvb3JkLCBjb29yZCwgY29vcmQsIGNvb3JkXSksIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChbcGFydFswXSwgcGFydFswXSwgcGFydFswXSwgcGFydFswXV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSkuZmxhdCgzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lX25vcm1hbHM6IHBvbHkubWFwKHBhcnQgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LnJlZHVjZSgoYXJyLGNvb3JkLGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBwYXJ0WyhwYXJ0Lmxlbmd0aCArIGkgLSAxKSAlIHBhcnQubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb21fbGFzdCA9IFtjb29yZFswXSAtIGxhc3RbMF0sIGNvb3JkWzFdIC0gbGFzdFsxXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcGFydFsoaSArIDEpICUgcGFydC5sZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9fbmV4dCA9IFtuZXh0WzBdIC0gY29vcmRbMF0sIG5leHRbMV0gLSBjb29yZFsxXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Zyb21fbGFzdFsxXSwgLWZyb21fbGFzdFswXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWy1mcm9tX2xhc3RbMV0sIGZyb21fbGFzdFswXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RvX25leHRbMV0sIC10b19uZXh0WzBdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbLXRvX25leHRbMV0sIHRvX25leHRbMF1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtdKS5jb25jYXQoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkID0gcGFydFswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHBhcnRbcGFydC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb21fbGFzdCA9IFtjb29yZFswXSAtIGxhc3RbMF0sIGNvb3JkWzFdIC0gbGFzdFsxXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcGFydFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvX25leHQgPSBbbmV4dFswXSAtIGNvb3JkWzBdLCBuZXh0WzFdIC0gY29vcmRbMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZnJvbV9sYXN0WzFdLCAtZnJvbV9sYXN0WzBdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbLWZyb21fbGFzdFsxXSwgZnJvbV9sYXN0WzBdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdG9fbmV4dFsxXSwgLXRvX25leHRbMF1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFstdG9fbmV4dFsxXSwgdG9fbmV4dFswXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpLmZsYXQoMyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiBwb2x5LmZsYXQoKS5yZWR1Y2UoKGEsIGIpID0+IFtNYXRoLm1pbihhWzBdLCBiWzBdKSwgTWF0aC5taW4oYVsxXSwgYlsxXSldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IHBvbHkuZmxhdCgpLnJlZHVjZSgoYSwgYikgPT4gW01hdGgubWF4KGFbMF0sIGJbMF0pLCBNYXRoLm1heChhWzFdLCBiWzFdKV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGh0bWxgXG4gICAgICAgICAgICA8Y2FudmFzXG4gICAgICAgICAgICAgICAgaWQ9XCJtYXBcIlxuICAgICAgICAgICAgICAgIEBtb3VzZW1vdmU9XCIke3RoaXMuaGFuZGxlTW91c2VNb3ZlfVwiXG4gICAgICAgICAgICAgICAgQHdoZWVsPVwiJHt0aGlzLmhhbmRsZU1vdXNlTW92ZX1cIlxuICAgICAgICAgICAgICAgIEBtb3VzZW91dD1cIiR7dGhpcy5oYW5kbGVNb3VzZU91dH1cIlxuICAgICAgICAgICAgICAgIEB0b3VjaHN0YXJ0PVwiJHt0aGlzLmhhbmRsZVRvdWNoU3RhcnR9XCJcbiAgICAgICAgICAgICAgICBAdG91Y2htb3ZlPVwiJHt0aGlzLmhhbmRsZVRvdWNoU3RhcnR9XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgIDwvY2FudmFzPlxuICAgICAgICBgO1xuICAgIH1cblxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ21hcC1iYWNrZW5kJywgTWFwQmFja2VuZFdlYkdsKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///50\n')}}]);